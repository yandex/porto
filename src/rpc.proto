syntax = "proto2";

// Portod daemon listens on /run/portod.socket unix socket.
// Protocol: Varint length, TContainerRequest req | TContainerResponse rsp.

package rpc;

// List of error codes
enum EError {
    // Request executed successfully. No errors occured.
    Success = 0;
    // Unknown critical error.
    Unknown = 1;
    // Unknown or bad request
    InvalidMethod = 2;
    // Container with specified name already exists. Can't create a new one.
    ContainerAlreadyExists = 3;
    // Container with specified name doesn't exist.
    ContainerDoesNotExist = 4;
    // Unknown property specified.
    InvalidProperty = 5;
    // Unknown data specified.
    InvalidData = 6;
    // Invalid value of property or data.
    InvalidValue = 7;
    // Can't perform specified operation in current container state.
    InvalidState = 8;
    // Operation is not supported due to some reasons (old kernel version, missing
    // kernel modules, etc).
    NotSupported = 9;
    // Requested resources are not available (e.g. can't allocate requested memory
    // without overcommiting).
    ResourceNotAvailable = 10;
    // Insufficient rights for performing requested operation.
    Permission = 11;

    // Can't create new volume with specified name, because there is already one.
    VolumeAlreadyExists = 12;
    // Volume with specified name doesn't exist.
    VolumeNotFound = 13;
    // Operation failed because of insufficient disk space.
    NoSpace = 14;
    // Operation can't be performed, because container or volume are in use by
    // other simultaneous operation.
    Busy = 15;
    // Volume already linked with container
    VolumeAlreadyLinked = 16;
    // Volume not linked with container
    VolumeNotLinked = 17;

    LayerAlreadyExists = 18;
    LayerNotFound = 19;

    NoValue = 20;

    VolumeNotReady = 21;

    // Cannot parse or execute command
    InvalidCommand = 22;

    // Error code is lost or came from future
    LostError = 23;

    DeviceNotFound = 24;

    InvalidPath = 25;

    InvalidNetworkAddress = 26;

    PortoFrozen = 27;

    LabelNotFound = 28;

    InvalidLabel = 29;

    HelperError = 30;
    HelperFatalError = 31;

    NotFound = 404;

    SocketError = 502;

    SocketUnavailable = 503;

    SocketTimeout = 504;

    PortodReloaded = 505;

    Taint = 666;

    // Reserved error code used by Porto internals. Can't be returned to a user.
    Queued = 1000;
}


message TContainerRequest {
    optional TContainerCreateRequest create = 1;
    optional TContainerDestroyRequest destroy = 2;
    optional TContainerListRequest list = 3;
    optional TContainerGetPropertyRequest getProperty = 4;
    optional TContainerSetPropertyRequest setProperty = 5;
    optional TContainerGetDataRequest getData = 6;  // deprecated

    optional TContainerStartRequest start = 7;
    optional TContainerStopRequest stop = 8;
    optional TContainerPauseRequest pause = 9;
    optional TContainerResumeRequest resume = 10;

    optional TContainerPropertyListRequest propertyList = 11;
    optional TContainerDataListRequest dataList = 12; // deprecated

    optional TContainerKillRequest kill = 13;

    optional TVersionRequest version = 14;

    optional TContainerGetRequest get = 15;

    optional TContainerWaitRequest wait = 16;

    optional TContainerCreateRequest createWeak = 17;
    optional TContainerRespawnRequest Respawn = 18;
    optional TContainerWaitRequest AsyncWait = 19;
    optional TContainerWaitRequest StopAsyncWait = 128;

    optional TFindLabelRequest FindLabel = 20;
    optional TSetLabelRequest SetLabel = 21;
    optional TIncLabelRequest IncLabel = 22;

    optional TCreateFromSpecRequest CreateFromSpec = 230;
    optional TUpdateFromSpecRequest UpdateFromSpec = 231;
    optional TListContainersRequest ListContainersBy = 232;

    optional TVolumePropertyListRequest listVolumeProperties = 103;
    optional TVolumeCreateRequest createVolume = 104;
    optional TVolumeLinkRequest linkVolume = 105;
    optional TVolumeLinkRequest LinkVolumeTarget = 120;
    optional TVolumeUnlinkRequest unlinkVolume = 106;
    optional TVolumeUnlinkRequest UnlinkVolumeTarget = 121;
    optional TVolumeListRequest listVolumes = 107;
    optional TVolumeTuneRequest tuneVolume = 108;
    optional TVolumeCheckRequest checkVolume = 109;

    optional TLayerImportRequest importLayer = 110;
    optional TLayerRemoveRequest removeLayer = 111;
    optional TLayerListRequest listLayers = 112;
    optional TLayerExportRequest exportLayer = 113;

    optional TLayerGetPrivateRequest getlayerprivate = 114;
    optional TLayerSetPrivateRequest setlayerprivate = 115;

    optional TStorageListRequest listStorage = 116;
    optional TStorageRemoveRequest removeStorage = 117;
    optional TStorageImportRequest importStorage = 118;
    optional TStorageExportRequest exportStorage = 119;

    optional TMetaStorage CreateMetaStorage = 122;
    optional TMetaStorage ResizeMetaStorage = 123;
    optional TMetaStorage RemoveMetaStorage = 124;

    optional TSetSymlinkRequest SetSymlink = 125;

    optional TNewVolumeRequest NewVolume = 126;
    optional TGetVolumeRequest GetVolume = 127;

    optional TConvertPathRequest convertPath = 200;
    optional TAttachProcessRequest attachProcess = 201;
    optional TLocateProcessRequest locateProcess = 202;
    optional TAttachProcessRequest AttachThread = 203;

    optional TGetSystemRequest GetSystem = 300;
    optional TSetSystemRequest SetSystem = 301;

    optional TClearStatisticsRequest ClearStatistics = 302;
}


message TContainerResponse {
    // Actually always set, hack for adding new error codes
    optional EError error = 1 [ default = LostError ];

    // Human readable comment - must be shown to user as is
    optional string errorMsg = 2;

    optional uint64 timestamp = 1000;       // for next changed_since

    optional TContainerListResponse list = 3;

    optional TContainerGetPropertyResponse getProperty = 4;
    optional TContainerGetDataResponse getData = 5;     // deprecated

    optional TContainerPropertyListResponse propertyList = 6;
    optional TContainerDataListResponse dataList = 7;   // deprecated

    optional TVersionResponse version = 8;

    optional TVolumeListResponse volumeList = 9;

    optional TContainerGetResponse get = 10;
    optional TContainerWaitResponse wait = 11;

    optional TVolumePropertyListResponse volumePropertyList = 12;

    optional TVolumeDescription volume = 13;        // reponse to createVolume
    optional TLayerListResponse layers = 14;
    optional TConvertPathResponse convertPath = 15;
    optional TLayerGetPrivateResponse layer_private = 16;
    optional TStorageListResponse storageList = 17;

    optional TLocateProcessResponse locateProcess = 18;

    optional TContainerWaitResponse AsyncWait = 19;

    optional TFindLabelResponse FindLabel = 20;
    optional TSetLabelResponse SetLabel = 21;
    optional TIncLabelResponse IncLabel = 22;

    optional TListContainersResponse ListContainersBy = 232;

    optional TNewVolumeResponse NewVolume = 126;
    optional TGetVolumeResponse GetVolume = 127;

    optional TGetSystemResponse GetSystem = 300;
    optional TSetSystemResponse SetSystem = 301;
}


// Common objects


message TStringMap {
    message TStringMapEntry {
        optional string key = 1;
        optional string val = 2;
    }
    // TODO replace with map
    // map<string, string> map = 1;
    repeated TStringMapEntry map = 1;
    optional bool merge = 2;        // in, default: replace
}


message TUintMap {
    message TUintMapEntry {
        optional string key = 1;
        optional uint64 val = 2;
    }
    // TODO replace with map
    // map<string, uint64> map = 1;
    repeated TUintMapEntry map = 1;
    optional bool merge = 2;        // in, default: replace
}


message TError {
    optional EError error = 1 [ default = LostError ];
    optional string msg = 2;
}


message TCred {
    optional string user = 1;       // requires user or uid or both
    optional fixed32 uid = 2;
    optional string group = 3;
    optional fixed32 gid = 4;
    repeated fixed32 grp = 5;       // out, supplementary groups
}


message TCapabilities {
    repeated string cap = 1;
    optional string hex = 2;        // out
}


// Container


message TContainerCommandArgv {
    repeated string argv = 1;
}

message TContainerEnvVar {
    required string name = 1;
    optional string value = 2;
    optional bool unset = 3;        // out
    optional string salt = 4;
    optional string hash = 5;
}

message TContainerEnv {
    repeated TContainerEnvVar var = 1;
    optional bool merge = 2;        // in, default: replace
}


message TContainerUlimit {
    required string type = 1;
    optional bool unlimited = 2;
    optional uint64 soft = 3;
    optional uint64 hard = 4;
    optional bool inherited = 5;    // out
}

message TContainerUlimits {
    repeated TContainerUlimit ulimit = 1;
    optional bool merge = 2;        // in, default: replace
}


message TContainerControllers {
    repeated string controller = 1;
}


message TContainerCgroup {
    required string controller = 1;
    required string path = 2;
    optional bool inherited = 3;
}

message TContainerCgroups {
    repeated TContainerCgroup cgroup = 1;
}


message TContainerCpuSet {
    optional string policy = 1;     // inherit|set|node|reserve|threads|cores
    optional uint32 arg = 2;        // for node|reserve|threads|cores
    optional string list = 3;       // for set
    repeated uint32 cpu = 4;        // for set (used if list isn't set)
    optional uint32 count = 5;      // out
    optional string mems = 6;
    optional int32 jail = 7;
}


message TContainerBindMount {
    required string source = 1;
    required string target = 2;
    repeated string flag = 3;
}

message TContainerBindMounts {
    repeated TContainerBindMount bind = 1;
}


message TContainerVolumeLink {
    required string volume = 1;
    optional string target = 2;
    optional bool required = 3;
    optional bool read_only = 4;
}

message TContainerVolumeLinks {
    repeated TContainerVolumeLink link = 1;
}


message TContainerVolumes {
    repeated string volume = 1;
}


message TContainerPlace {
    required string place = 1;
    optional string alias = 2;
}

message TContainerPlaceConfig {
    repeated TContainerPlace cfg = 1;
}


message TContainerDevice {
    required string device = 1;
    required string access = 2;
    optional string path = 3;
    optional string mode = 4;
    optional string user = 5;
    optional string group = 6;
}

message TContainerDevices {
    repeated TContainerDevice device = 1;
    optional bool merge = 2;        // in, default: replace
}


message TContainerNetOption {
    required string opt = 1;
    repeated string arg = 2;
}

message TContainerNetConfig {
    repeated TContainerNetOption cfg = 1;
    optional bool inherited = 2;    // out
}


message TContainerIpLimit {
    required string policy = 1;     // any|none|some
    repeated string ip = 2;
}


message TContainerIpConfig {
    message TContainerIp {
        required string dev = 1;
        required string ip = 2;
    }
    repeated TContainerIp cfg = 1;
}


message TVmStat {
    optional uint64 count = 1;
    optional uint64 size = 2;
    optional uint64 max_size = 3;
    optional uint64 used = 4;
    optional uint64 max_used = 5;
    optional uint64 anon = 6;
    optional uint64 file = 7;
    optional uint64 shmem = 8;
    optional uint64 huge = 9;
    optional uint64 swap = 10;
    optional uint64 data = 11;
    optional uint64 stack = 12;
    optional uint64 code = 13;
    optional uint64 locked = 14;
    optional uint64 table = 15;
}

message TContainerStatus {
    optional string absolute_name = 1;  // out, "/porto/..."
    optional string state = 2;          // out
    optional uint64 id = 3;             // out
    optional uint32 level = 4;          // out
    optional string parent = 5;         // out, "/porto/..."

    optional string absolute_namespace = 6;    // out

    optional int32 root_pid = 7;       // out
    optional int32 exit_status = 8;    // out
    optional int32 exit_code = 9;      // out
    optional bool core_dumped = 10;     // out
    optional TError start_error = 11;   // out
    optional uint64 time = 12;          // out
    optional uint64 dead_time = 13;     // out

    optional TCapabilities capabilities_allowed = 14;           // out
    optional TCapabilities capabilities_ambient_allowed = 15;   // out
    optional string root_path = 16;     // out, in client namespace
    optional uint64 stdout_offset = 17; // out
    optional uint64 stderr_offset = 18; // out
    optional string stderr = 69; // out
    optional string stdout = 70; // out

    optional uint64 creation_time = 19; // out
    optional uint64 start_time = 20;    // out
    optional uint64 death_time = 21;    // out
    optional uint64 change_time = 22;   // out
    optional bool no_changes = 23;      // out, change_time < changed_since
    optional string extra_properties = 73;

    optional TContainerCgroups cgroups = 24;     // out
    optional TContainerCpuSet cpu_set_affinity = 25;     // out

    optional uint64 cpu_usage = 26;            // out
    optional uint64 cpu_usage_system = 27;     // out
    optional uint64 cpu_wait = 28;             // out
    optional uint64 cpu_throttled = 29;        // out

    optional uint64 process_count = 30;        // out
    optional uint64 thread_count = 31;         // out
    optional TUintMap io_read = 32;        // out, bytes
    optional TUintMap io_write = 33;       // out, bytes
    optional TUintMap io_ops = 34;         // out, ops
    optional TUintMap io_time = 35;        // out, ns

    optional TUintMap place_usage = 36;
    optional uint64 memory_usage = 37;         // out, bytes

    optional uint64 memory_guarantee_total = 38;   // out

    optional uint64 memory_limit_total = 39;   // out

    optional uint64 anon_limit_total = 40;
    optional uint64 anon_usage = 41;           // out, bytes
    optional double cpu_guarantee_total = 42;
    optional double cpu_guarantee_bound = 421;
    optional double cpu_limit_total = 422;
    optional double cpu_limit_bound = 423;

    optional uint64 cache_usage = 43;          // out, bytes

    optional uint64 hugetlb_usage = 44;        // out, bytes
    optional uint64 hugetlb_limit = 45;

    optional uint64 minor_faults = 46;         // out
    optional uint64 major_faults = 47;         // out
    optional uint64 memory_reclaimed = 48;     // out
    optional TVmStat virtual_memory = 49;      // out

    optional uint64 shmem_usage = 71;          // out, bytes
    optional uint64 mlock_usage = 72;          // out, bytes

    optional uint64 oom_kills = 50;            // out
    optional uint64 oom_kills_total = 51;      // out
    optional bool oom_killed = 52;             // out

    optional TUintMap net_bytes = 54;          // out
    optional TUintMap net_packets = 55;        // out
    optional TUintMap net_drops = 56;          // out
    optional TUintMap net_overlimits = 57;     // out
    optional TUintMap net_rx_bytes = 58;       // out
    optional TUintMap net_rx_packets = 59;     // out
    optional TUintMap net_rx_drops = 60;       // out
    optional TUintMap net_tx_bytes = 61;       // out
    optional TUintMap net_tx_packets = 62;     // out
    optional TUintMap net_tx_drops = 63;       // out
    optional TUintMap net_netstat = 163;       // out
    optional TUintMap net_snmp = 263;          // out

    optional TContainerVolumeLinks volumes_linked = 64; // out
    optional TContainerVolumes volumes_owned = 65;

    repeated TError error = 66;   // out
    repeated TError warning = 67; // out
    repeated TError taint = 68;   // out
}

message TContainerSpec {
    required string name = 1;           // in client namespace
    optional bool weak = 2;
    optional string private = 3;
    optional TStringMap labels = 4;

    optional string command = 5;
    optional TContainerCommandArgv command_argv = 76;
    optional TContainerEnv env = 6;
    optional TContainerEnv env_secret = 90;  // in, out hides values
    optional TContainerUlimits ulimit = 7;
    optional string core_command = 8;

    optional bool isolate = 9;
    optional string virt_mode = 10;
    optional string enable_porto = 11;
    optional string porto_namespace = 12;
    optional string cgroupfs = 78;
    optional bool userns = 79;
    optional bool unshare_on_exec = 80;

    optional uint64 aging_time = 13;

    optional TCred task_cred = 14;
    optional string user = 15;
    optional string group = 16;

    optional TCred owner_cred = 17;
    optional string owner_user = 18;
    optional string owner_group = 19;
    optional string owner_containers = 77;

    optional TCapabilities capabilities = 20;
    optional TCapabilities capabilities_ambient = 21;

    optional string root = 22;          // in parent namespace
    optional bool root_readonly = 23;
    optional TContainerBindMounts bind = 24;
    optional TStringMap symlink = 25;
    optional TContainerDevices devices = 26;
    optional TContainerPlaceConfig place = 27;
    optional TUintMap place_limit = 28;

    optional string cwd = 29;
    optional string stdin_path = 30;
    optional string stdout_path = 31;
    optional string stderr_path = 32;
    optional uint64 stdout_limit = 33;
    optional uint32 umask = 34;

    optional bool respawn = 35;
    optional uint64 respawn_count = 36;
    optional int64 max_respawns = 37;
    optional uint64 respawn_delay = 38;

    optional TContainerControllers controllers = 39;
    optional bool link_memory_writeback_blkio = 81;

    optional string cpu_policy = 40;   // normal|idle|batch|high|rt
    optional double cpu_weight = 41;   // 0.01 .. 100

    optional double cpu_guarantee = 42;        // in cores
    optional double cpu_limit = 43;            // in cores
    optional double cpu_limit_total = 44;      // deprecated (value moved to TContainerStatus)
    optional uint64 cpu_period = 45;           // ns

    optional TContainerCpuSet cpu_set = 46;

    optional uint64 thread_limit = 47;

    optional string io_policy = 48;    // none|rt|high|normal|batch|idle
    optional double io_weight = 49;    // 0.01 .. 100

    optional TUintMap io_limit = 50;       // bps
    optional TUintMap io_ops_limit = 51;   // iops

    optional uint64 memory_guarantee = 52;     // bytes

    optional uint64 memory_limit = 53;         // bytes

    optional uint64 anon_limit = 54;
    optional uint64 anon_max_usage = 55;

    optional uint64 dirty_limit = 56;

    optional uint64 hugetlb_limit = 57;

    optional bool recharge_on_pgfault = 58;
    optional bool pressurize_on_death = 59;
    optional bool anon_only = 60;

    optional int32 oom_score_adj = 61;         // -1000 .. +1000
    optional bool oom_is_fatal = 62;

    optional TContainerNetConfig net = 63;
    optional TContainerIpLimit ip_limit = 64;
    optional TContainerIpConfig ip = 65;
    optional TContainerIpConfig default_gw = 66;
    optional string hostname = 67;
    optional string resolv_conf = 68;
    optional string etc_hosts = 69;
    optional TStringMap sysctl = 70;
    optional TUintMap net_guarantee = 71;      // bytes per second
    optional TUintMap net_limit = 72;          // bytes per second
    optional TUintMap net_rx_limit = 73;       // bytes per second

    optional TContainerVolumes volumes_required = 75;
}

message TContainer {
    required TContainerSpec spec = 1;
    optional TContainerStatus status = 2;
    optional TError error = 3;
}


// Volumes


message TVolumeProperty {
    required string name = 1;
    required string value = 2;
}

message TVolumeDescription {
    required string path = 1;
    repeated TVolumeProperty properties = 2;
    repeated string containers = 3;
    repeated TVolumeLink links = 4;

    optional uint64 change_time = 5;
    optional bool no_changes = 6;           // change_time < changed_since
}


message TVolumeLink {
    required string container = 1;
    optional string target = 2;         // absolute path in container, default: anon
    optional bool required = 3;         // container cannot work without it
    optional bool read_only = 4;
    optional string host_target = 5;    // out, absolute path in host
    optional bool container_root = 6;   // in, set container root
    optional bool container_cwd = 7;     // in, set container cwd
}

message TVolumeResource {
    optional uint64 limit = 1;
    optional uint64 guarantee = 2;
    optional uint64 usage = 3;          // out
    optional uint64 available = 4;      // out
}

message TVolumeDirectory {
    required string path = 1;           // relative path in volume
    optional TCred cred = 2;            // default: volume cred
    optional fixed32 permissions = 3;   // default: volume permissions
}

message TVolumeSymlink {
    required string path = 1;           // relative path in volume
    required string target_path = 2;
}

message TVolumeShare {
    required string path = 1;           // relative path in volume
    required string origin_path = 2;    // absolute path to origin
    optional bool cow = 3;              // default: mutable
}

message TVolumeSpec {
    optional string path = 1;               // path in container, default: auto
    optional string container = 2;          // default: self
    repeated TVolumeLink links = 3;         // default: anon link to self

    optional string id = 4;                 // out
    optional string state = 5;              // out

    optional string private_value = 6;      // at most 4096 bytes

    optional string device_name = 7;        // out

    optional string backend = 10;           // default: auto
    optional string place = 11;             // path in host, default: default place for self
    optional string storage = 12;           // default: temp
    repeated string layers = 13;
    optional bool read_only = 14;

    // defines root directory user, group and permissions
    optional TCred cred = 20;               // default: self task cred
    optional fixed32 permissions = 21;      // default: 0775

    optional TVolumeResource space = 22;
    optional TVolumeResource inodes = 23;

    optional TCred owner = 30;              // default: self owner
    optional string owner_container = 31;   // default: self
    optional string place_key = 32;         // out
    optional string creator = 33;           // out
    optional bool auto_path = 34;           // out
    optional uint32 device_index = 35;      // out
    optional uint64 build_time = 37;        // out

    // customization at creation
    repeated TVolumeDirectory directories = 40; // in
    repeated TVolumeSymlink symlinks = 41;      // in
    repeated TVolumeShare shares = 42;          // in

    optional uint64 change_time = 50;       // out
    optional bool no_changes = 51;          // out, change_time < changed_since
}


message TLayerDescription {
    required string name = 1;
    required string owner_user = 2;
    required string owner_group = 3;
    required uint64 last_usage = 4;
    required string private_value = 5;
}


message TStorageDescription {
    required string name = 1;
    required string owner_user = 2;
    required string owner_group = 3;
    required uint64 last_usage = 4;
    required string private_value = 5;
}


message TMetaStorage {
    required string name = 1;
    optional string place = 2;
    optional string private_value = 3;
    optional uint64 space_limit = 4;
    optional uint64 inode_limit = 5;

    optional uint64 space_used = 6;         // out
    optional uint64 space_available = 7;    // out
    optional uint64 inode_used = 8;         // out
    optional uint64 inode_available = 9;    // out
    optional string owner_user = 10;        // out
    optional string owner_group = 11;       // out
    optional uint64 last_usage = 12;        // out
}


// COMMANDS

// System

// Get porto version
message TVersionRequest {
}

message TVersionResponse {
    required string tag = 1;
    required string revision = 2;
}


// Get porto statistics
message TGetSystemRequest {
}

// Clear porto statistics
message TClearStatisticsRequest {
    optional string stat = 1;
}

message TGetSystemResponse {
    required string porto_version = 1;
    required string porto_revision = 2;
    required string kernel_version = 3;

    required fixed64 errors = 4;
    required fixed64 warnings = 5;
    required fixed64 fatals = 11;
    required fixed64 porto_starts = 6;
    required fixed64 porto_uptime = 7;
    required fixed64 master_uptime = 8;
    optional fixed64 taints = 9;

    optional bool frozen = 10;
    required bool verbose = 100;
    required bool debug = 101;
    required fixed64 log_lines = 102;
    required fixed64 log_bytes = 103;

    required fixed64 stream_rotate_bytes = 104;
    required fixed64 stream_rotate_errors = 105;

    required fixed64 log_lines_lost = 106;
    required fixed64 log_bytes_lost = 107;
    required fixed64 log_open = 108;

    required fixed64 container_count = 200;
    required fixed64 container_limit = 201;
    required fixed64 container_running = 202;
    required fixed64 container_created = 203;
    required fixed64 container_started = 204;
    required fixed64 container_start_failed = 205;
    required fixed64 container_oom = 206;
    required fixed64 container_buried = 207;
    required fixed64 container_lost = 208;
    optional fixed64 container_tainted = 209;
    optional fixed64 postfork_issues = 210;

    required fixed64 volume_count = 300;
    required fixed64 volume_limit = 301;
    required fixed64 volume_created = 303;
    required fixed64 volume_failed = 304;
    required fixed64 volume_links = 305;
    required fixed64 volume_links_mounted = 306;
    required fixed64 volume_lost = 307;

    required fixed64 layer_import = 390;
    required fixed64 layer_export = 391;
    required fixed64 layer_remove = 392;

    required fixed64 client_count = 400;
    required fixed64 client_max = 401;
    required fixed64 client_connected = 402;

    required fixed64 request_queued = 500;
    required fixed64 request_completed = 501;
    required fixed64 request_failed = 502;
    required fixed64 request_threads = 503;
    required fixed64 request_longer_1s = 504;
    required fixed64 request_longer_3s = 505;
    required fixed64 request_longer_30s = 506;
    required fixed64 request_longer_5m = 507;
    optional fixed64 request_top_running_time = 508;  // seconds

    required fixed64 fail_system = 600;
    required fixed64 fail_invalid_value = 601;
    required fixed64 fail_invalid_command = 602;
    optional fixed64 fail_memory_guarantee = 603;
    optional fixed64 fail_invalid_netaddr = 604;

    optional fixed64 network_count = 700;
    optional fixed64 network_created = 701;
    optional fixed64 network_problems = 702;
    optional fixed64 network_repairs = 703;
}


// Change porto state
message TSetSystemRequest {
    optional bool frozen = 10;
    optional bool verbose = 100;
    optional bool debug = 101;
}

message TSetSystemResponse {
}

message TCreateFromSpecRequest {
    required TContainerSpec container = 1;
    repeated TVolumeSpec volumes = 2;
    optional bool start = 3;
}

message TUpdateFromSpecRequest {
    required TContainerSpec container = 1;
}

message TListContainersFilter {
    required string name = 1;    // name or wildcards, default: all
    optional TStringMap labels = 2;
    optional uint64 changed_since = 3;  // change_time >= changed_since
}

message TStreamDumpOptions {
    required uint64 stdstream_offset = 2; // default: 0
    required uint64 stdstream_limit = 3;  // default: 8Mb
}

message TListContainersFieldOptions {
    repeated string properties = 1;       // property names, default: all
    optional TStreamDumpOptions stdout_options = 2;    // for GetIndexed stdout
    optional TStreamDumpOptions stderr_options = 3;    // for GetIndexed stderr
}

message TListContainersRequest {
    repeated TListContainersFilter filters = 1;
    optional TListContainersFieldOptions field_options = 2;
}

message TListContainersResponse {
    repeated TContainer containers = 1;
}

// List available properties
message TContainerPropertyListRequest {
}

message TContainerPropertyListResponse {
    message TContainerPropertyListEntry {
        required string name = 1;
        required string desc = 2;
        optional bool read_only = 3;
        optional bool dynamic = 4;
    }
    repeated TContainerPropertyListEntry list = 1;
}


// deprecated, use PropertyList
message TContainerDataListRequest {
}

message TContainerDataListResponse {
    message TContainerDataListEntry {
        required string name = 1;
        required string desc = 2;
    }
    repeated TContainerDataListEntry list = 1;
}


// Create stopped container
message TContainerCreateRequest {
    required string name = 1;
}


// Stop and destroy container
message TContainerDestroyRequest {
    required string name = 1;
}


// List container names
message TContainerListRequest {
    optional string mask = 1;
    optional uint64 changed_since = 2;  // change_time >= changed_since
}

message TContainerListResponse {
    repeated string name = 1;
}


// Read one property
message TContainerGetPropertyRequest {
    required string name = 1;
    required string property = 2;
    // update cached counters
    optional bool sync = 3;
    optional bool real = 4;
}

message TContainerGetPropertyResponse {
    required string value = 1;
}


// Alias for GetProperty, deprecated
message TContainerGetDataRequest {
    required string name = 1;
    required string data = 2;
    // update cached counters
    optional bool sync = 3;
    optional bool real = 4;
}

message TContainerGetDataResponse {
    required string value = 1;
}


// Change one property
message TContainerSetPropertyRequest {
    required string name = 1;
    required string property = 2;
    required string value = 3;
}


// Get multiple properties/data of many containers with one request
message TContainerGetRequest {
    // list of containers or wildcards, "***" - all
    repeated string name = 1;

    // list of properties/data
    repeated string variable = 2;

    // do not wait busy containers
    optional bool nonblock = 3;

    // update cached counters
    optional bool sync = 4;
    optional bool real = 5;

    // change_time >= changed_since
    optional uint64 changed_since = 6;
}

message TContainerGetResponse {
    message TContainerGetValueResponse {
        required string variable = 1;
        optional EError error = 2;
        optional string errorMsg = 3;
        optional string value = 4;
    }

    message TContainerGetListResponse {
        required string name = 1;
        repeated TContainerGetValueResponse keyval = 2;

        optional uint64 change_time = 3;
        optional bool no_changes = 4;   // change_time < changed_since
    }

    repeated TContainerGetListResponse list = 1;
}


// Start stopped container
message TContainerStartRequest {
    required string name = 1;
}


// Restart dead container
message TContainerRespawnRequest {
    required string name = 1;
}


// Stop dead or running container
message TContainerStopRequest {
    required string name = 1;
    // Timeout in 1/1000 seconds between SIGTERM and SIGKILL, default 30s
    optional uint32 timeout_ms = 2;
}


// Freeze running container
message TContainerPauseRequest {
    required string name = 1;
}


// Unfreeze paused container
message TContainerResumeRequest {
    required string name = 1;
}


// Translate filesystem path between containers
message TConvertPathRequest {
    required string path = 1;
    required string source = 2;
    required string destination = 3;
}

message TConvertPathResponse {
    required string path = 1;
}


// Wait while container(s) is/are in running state
message TContainerWaitRequest {
    // list of containers or wildcards, "***" - all
    repeated string name = 1;

    // timeout in 1/1000 seconds, 0 - nonblock
    optional uint32 timeout_ms = 2;

    // list of label names or wildcards
    repeated string label = 3;

    // async wait with target_state works only once
    optional string target_state = 4;
}

message TContainerWaitResponse {
    required string name = 1;           // container name
    optional string state = 2;          // container state or timeout
    optional uint64 when = 3;           // unix time stamp in seconds
    optional string label = 4;
    optional string value = 5;
}


// Send signal main process in container
message TContainerKillRequest {
    required string name = 1;
    required int32 sig = 2;
}


// Move process into container
message TAttachProcessRequest {
    required string name = 1;
    required uint32 pid = 2;
    required string comm = 3; // ignored if empty
}


// Determine container by pid
message TLocateProcessRequest {
    required uint32 pid = 1;
    required string comm = 2; // ignored if empty
}

message TLocateProcessResponse {
    required string name = 1;
}


// Labels


message TFindLabelRequest {
    optional string mask = 1;           // containers name or wildcard
    optional string state = 2;          // filter by container state
    required string label = 3;          // label name or wildcard
    optional string value = 4;          // filter by label value
}

message TFindLabelResponse {
    message TFindLabelEntry {
        required string name = 1;
        required string state = 2;
        required string label = 3;
        required string value = 4;
    }
    repeated TFindLabelEntry list = 1;
}


message TSetLabelRequest {
    required string name = 1;
    required string label = 2;
    required string value = 3;
    optional string prev_value = 4;     // fail with Busy if does not match
    optional string state = 5;          // fail with InvalidState if not match
}

message TSetLabelResponse {
    optional string prev_value = 1;
    optional string state = 2;
}


message TIncLabelRequest {
    required string name = 1;
    required string label = 2;          // missing label starts from 0
    optional int64 add = 3 [ default = 1];
}

message TIncLabelResponse {
    required int64 result = 1;
}


message TSetSymlinkRequest {
    required string container = 1;
    required string symlink = 2;
    optional string target = 3;
}


// Volumes


message TNewVolumeRequest {
    required TVolumeSpec volume = 1;
}

message TNewVolumeResponse {
    required TVolumeSpec volume = 1;
}


message TGetVolumeRequest {
    optional string container = 1;  // get paths in container, default: self
    repeated string path = 2;       // volume path in container, default: all
    optional uint64 changed_since = 3;  // change_time >= changed_since
}

message TGetVolumeResponse {
    repeated TVolumeSpec volume = 1;
}


// List available volume properties
message TVolumePropertyListRequest {
}

message TVolumePropertyListResponse {
    message TVolumePropertyDescription {
        required string name = 1;
        required string desc = 2;
    }
    repeated TVolumePropertyDescription properties = 1;
}


// Create new volume
// "createVolume" returns TVolumeDescription in "volume"
message TVolumeCreateRequest {
    optional string path = 1;
    repeated TVolumeProperty properties = 2;
}


message TVolumeLinkRequest {
    required string path = 1;
    optional string container = 2;      // default - self
    optional string target = 3;         // path in container, "" - anon
    optional bool required = 4;         // stop container at fail
    optional bool read_only = 5;
}


message TVolumeUnlinkRequest {
    required string path = 1;
    optional string container = 2;      // default - self, "***" - all
    optional bool strict = 3;           // non-lazy umount
    optional string target = 4;         // path in container, "" - anon, default - "***" - all
}


message TVolumeListRequest {
    optional string path = 1;
    optional string container = 2;
    optional uint64 changed_since = 3;  // change_time >= changed_since
}

message TVolumeListResponse {
    repeated TVolumeDescription volumes = 1;
}


message TVolumeTuneRequest {
    required string path = 1;
    repeated TVolumeProperty properties = 2;
}

message TVolumeCheckRequest {
    required string path = 1;
}


// Layers


message TLayerListRequest {
    optional string place = 1;
    optional string mask = 2;
}

message TLayerListResponse {
    repeated string layer = 1;
    repeated TLayerDescription layers = 2;
}


message TLayerImportRequest {
    required string layer = 1;
    required string tarball = 2;
    required bool merge = 3;
    optional string place = 4;
    optional string private_value = 5;
    optional string compress = 6;
    optional bool verbose_error = 7;
    optional string mem_cgroup = 8;
}


message TLayerExportRequest {
    required string volume = 1;
    required string tarball = 2;
    optional string layer = 3;
    optional string place = 4;
    optional string compress = 5;
}


message TLayerRemoveRequest {
    required string layer = 1;
    optional string place = 2;
    optional bool async = 3;
}


message TLayerGetPrivateRequest {
    required string layer = 1;
    optional string place = 2;
}

message TLayerGetPrivateResponse {
    optional string private_value = 1;
}


message TLayerSetPrivateRequest {
    required string layer = 1;
    optional string place = 2;
    required string private_value = 3;
}


// Storages


message TStorageListRequest {
    optional string place = 1;
    optional string mask = 2;
}

message TStorageListResponse {
    repeated TStorageDescription storages = 1;
    repeated TMetaStorage meta_storages = 2;
}


message TStorageRemoveRequest {
    required string name = 1;
    optional string place = 2;
}


message TStorageImportRequest {
    required string name = 1;
    required string tarball = 2;
    optional string place = 3;
    optional string private_value = 5;
    optional string compress = 6;
}


message TStorageExportRequest {
    required string name = 1;
    required string tarball = 2;
    optional string place = 3;
    optional string compress = 4;
}
